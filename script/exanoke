#!/usr/bin/env python

# Exanoke reference interpreter

from optparse import OptionParser
import re
import sys


class AST(object):
    def __init__(self, type, children=None, value=None):
        self.type = type
        self.value = value
        if children is not None:
            self.children = children
        else:
            self.children = []

    def add_child(self, item):
        self.children.append(item)

    def __repr__(self):
        if self.value is None:
            return 'AST(%r,%r)' % (self.type, self.children)
        if not self.children:
            return 'AST(%r,value=%r)' % (self.type, self.value)
        return 'AST(%r,%r,value=%r)' % (self.type, self.children, self.value)


class Scanner(object):
    def __init__(self, text):
        self.text = text
        self.token = None
        self.type = None
        self.scan()

    def scan_pattern(self, pattern, type, token_group=1, rest_group=2):
        pattern = r'^(' + pattern + r')(.*?)$'
        match = re.match(pattern, self.text, re.DOTALL)
        if not match:
            return False
        else:
            self.type = type
            self.token = match.group(token_group)
            self.text = match.group(rest_group)
            #print >>sys.stderr, "(%r/%s->%r)" % (self.token, self.type, self.text)
            return True

    def scan(self):
        self.scan_pattern(r'[ \t\r\n]*', 'whitespace')
        if not self.text:
            self.token = None
            self.type = 'EOF'
            return
        if self.scan_pattern(r'\(|\)|\,|\#', 'goose egg'):
            return
        if self.scan_pattern(r'[A-Z]+', 'atom'):
            return
        if self.scan_pattern(r'\<?[a-z]+\??', 'identifier'):
            return
        if self.scan_pattern(r'.', 'unknown character'):
            return
        else:
            raise ValueError, "this should never happen, self.text=(%s)" % self.text

    def expect(self, token):
        if self.token == token:
            self.scan()
        else:
            raise SyntaxError("Expected '%s', but found '%s'" %
                              (token, self.token))

    def expect_type(self, type):
        self.check_type(type)
        self.scan()

    def on(self, token):
        return self.token == token

    def on_type(self, type):
        return self.type == type

    def check_type(self, type):
        if not self.type == type:
            raise SyntaxError("Expected %s, but found %s ('%s')" %
                              (type, self.type, self.token))

    def consume(self, token):
        if self.token == token:
            self.scan()
            return True
        else:
            return False


class Parser(object):
    def __init__(self, text):
        self.scanner = Scanner(text)
        self.defining = None

    def program(self):
        fundefs = []
        while self.scanner.on('def'):
            fundefs.append(self.fundef())
        self.defining = None
        expr = self.expr()
        return AST('Program', [expr] + fundefs)

    def ident(self):
        self.scanner.check_type('identifier')
        name = self.scanner.token
        self.scanner.scan()
        return name

    def fundef(self):
        self.scanner.expect('def')
        name = self.ident()
        args = []
        self.scanner.expect('(')
        self.scanner.expect('#')
        while self.scanner.consume(','):
            args.append(self.ident())
        self.scanner.expect(')')
        self.defining = name
        expr = self.expr()
        self.defining = None
        return AST('FunDef', [expr] + args, value=name)

    def expr(self):
        if self.scanner.consume("cons"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(",")
            e2 = self.expr()
            self.scanner.expect(")")
            return AST('Cons', [e1, e2])
        elif self.scanner.consume("if"):
            e1 = self.expr()
            self.scanner.expect("then")
            e2 = self.expr()
            self.scanner.expect("else")
            e3 = self.expr()
            return AST('If', [e1, e2, e3])
        elif self.scanner.consume("self"):
            if self.defining is None:
                raise SyntaxError('Use of "self" outside of a function body')
            args = []
            self.scanner.expect("(")
            e1 = self.smaller()
            args.append(e1)
            while self.scanner.consume(','):
                args.append(self.expr())
            self.scanner.expect(")")
            return AST('Self', args)
        elif self.scanner.consume("eq?"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(",")
            e2 = self.expr()
            self.scanner.expect(")")
            return AST('Eq?', [e1, e2])
        elif self.scanner.consume("cons?"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Cons?', [e1])
        elif self.scanner.consume("not"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Not', [e1])
        elif self.scanner.consume("#"):
            if self.defining is None:
                raise SyntaxError('Use of "#" outside of a function body')
            return AST('ArgRef', value=0)
        elif self.scanner.on_type("atom"):
            atom = self.scanner.token
            self.scanner.scan()
            return AST('Atom', value=atom)
        elif self.scanner.on_type("identifier"):
            ident = self.scanner.token
            self.scanner.scan()
            if self.scanner.on('('):
                self.scanner.expect('(')
                args = [self.expr()]
                while self.scanner.consume(','):
                    args.append(self.expr())
                self.scanner.expect(')')
                return AST('Call', args, value=ident)
            else:
                return AST('ArgRef', value=ident)
        else:
            return self.smaller()

    def smaller(self):
        if self.scanner.consume("<head"):
            e1 = self.smallerterm()
            return AST('Head', [e1])
        elif self.scanner.consume("<tail"):
            e1 = self.smallerterm()
            return AST('Tail', [e1])
        elif self.scanner.consume("<if"):
            e1 = self.expr()
            self.scanner.expect("then")
            e2 = self.smallerterm()
            self.scanner.expect("else")
            e3 = self.smallerterm()
            return AST('If', [e1, e2, e3])
        else:
            raise SyntaxError('Expected <smaller>, found "%s"' %
                              self.scanner.token)

    def smallerterm(self):
        if self.scanner.consume("#"):
            return AST('ArgRef', value=0)
        else:
            return self.smaller()


def main(argv):
    optparser = OptionParser(__doc__)
    optparser.add_option("-a", "--show-ast",
                         action="store_true", dest="show_ast", default=False,
                         help="show parsed AST instead of evaluating")
    optparser.add_option("-t", "--test",
                         action="store_true", dest="test", default=False,
                         help="run test cases and exit")
    (options, args) = optparser.parse_args(argv[1:])
    if options.test:
        import doctest
        (fails, something) = doctest.testmod()
        if fails == 0:
            print "All tests passed."
            sys.exit(0)
        else:
            sys.exit(1)
    file = open(args[0])
    text = file.read()
    file.close()
    p = Parser(text)
    try:
        prog = p.program()
    except SyntaxError as e:
        print >>sys.stderr, str(e)
        sys.exit(1)
    if options.show_ast:
        from pprint import pprint
        pprint(prog)
        sys.exit(0)
    # eval prog
    sys.exit(0)


if __name__ == "__main__":
    main(sys.argv)
