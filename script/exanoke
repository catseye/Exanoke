#!/usr/bin/env python

# Exanoke reference interpreter
# ... implemented in a Questionable Manner

from optparse import OptionParser
import re
import sys


class AST(object):
    def __init__(self, type, children=None, value=None):
        self.type = type
        self.value = value
        if children is not None:
            self.children = children
        else:
            self.children = []

    def add_child(self, item):
        self.children.append(item)

    def __repr__(self):
        if self.value is None:
            return 'AST(%r,%r)' % (self.type, self.children)
        if not self.children:
            return 'AST(%r,value=%r)' % (self.type, self.value)
        return 'AST(%r,%r,value=%r)' % (self.type, self.children, self.value)


class Scanner(object):
    def __init__(self, text):
        self.text = text
        self.token = None
        self.type = None
        self.scan()

    def scan_pattern(self, pattern, type, token_group=1, rest_group=2):
        pattern = r'^(' + pattern + r')(.*?)$'
        match = re.match(pattern, self.text, re.DOTALL)
        if not match:
            return False
        else:
            self.type = type
            self.token = match.group(token_group)
            self.text = match.group(rest_group)
            #print >>sys.stderr, "(%r/%s->%r)" % (self.token, self.type, self.text)
            return True

    def scan(self):
        self.scan_pattern(r'[ \t\r\n]*', 'whitespace')
        if not self.text:
            self.token = None
            self.type = 'EOF'
            return
        if self.scan_pattern(r'\(|\)|\,|\#', 'goose egg'):
            return
        if self.scan_pattern(r':[a-zA-Z]+', 'atom'):
            return
        if self.scan_pattern(r'[a-zA-Z]+\??', 'identifier'):
            return
        if self.scan_pattern(r'\<[a-z]+', 'smallifier'):
            return
        if self.scan_pattern(r'.', 'unknown character'):
            return
        else:
            raise ValueError, "this should never happen, self.text=(%s)" % self.text

    def expect(self, token):
        if self.token == token:
            self.scan()
        else:
            raise SyntaxError("Expected '%s', but found '%s'" %
                              (token, self.token))

    def expect_type(self, type):
        self.check_type(type)
        self.scan()

    def on(self, token):
        return self.token == token

    def on_type(self, type):
        return self.type == type

    def check_type(self, type):
        if not self.type == type:
            raise SyntaxError("Expected %s, but found %s ('%s')" %
                              (type, self.type, self.token))

    def consume(self, token):
        if self.token == token:
            self.scan()
            return True
        else:
            return False


class Parser(object):
    def __init__(self, text):
        self.scanner = Scanner(text)
        self.defining = None
        self.self_arity = None
        self.defined = {}
        self.formals = None

    def program(self):
        fundefs = []
        while self.scanner.on('def'):
            fundefs.append(self.fundef())
        self.defining = None
        expr = self.expr()
        return AST('Program', [expr] + fundefs)

    def ident(self):
        self.scanner.check_type('identifier')
        name = self.scanner.token
        self.scanner.scan()
        return name

    def fundef(self):
        self.scanner.expect('def')
        name = self.ident()
        if name in self.defined:
            raise SyntaxError('Function "%s" already defined' % name)
        args = []
        self.scanner.expect('(')
        self.scanner.expect('#')
        self.formals = {}
        i = 1
        while self.scanner.consume(','):
            ident = self.ident()
            args.append(ident)
            self.formals[ident] = i
            i += 1
        self.scanner.expect(')')
        self.defining = name
        self.self_arity = len(args) + 1
        expr = self.expr()
        self.defining = None
        self.self_arity = None
        self.formals = None
        self.defined[name] = len(args) + 1
        return AST('FunDef', [expr] + args, value=name)

    def expr(self):
        if self.scanner.consume("cons"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(",")
            e2 = self.expr()
            self.scanner.expect(")")
            return AST('Cons', [e1, e2])
        elif self.scanner.consume("head"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Head', [e1])
        elif self.scanner.consume("tail"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Tail', [e1])
        elif self.scanner.consume("if"):
            e1 = self.expr()
            self.scanner.expect("then")
            e2 = self.expr()
            self.scanner.expect("else")
            e3 = self.expr()
            return AST('If', [e1, e2, e3])
        elif self.scanner.consume("self"):
            if self.defining is None:
                raise SyntaxError('Use of "self" outside of a function body')
            args = []
            self.scanner.expect("(")
            e1 = self.smaller()
            args.append(e1)
            while self.scanner.consume(','):
                args.append(self.expr())
            if len(args) != self.self_arity:
                raise SyntaxError('Arity mismatch on self (expected %d, got %d)' %
                    (self.self_arity, len(args)))
            self.scanner.expect(")")
            return AST('Call', args, value=self.defining)
        elif self.scanner.consume("eq?"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(",")
            e2 = self.expr()
            self.scanner.expect(")")
            return AST('Eq?', [e1, e2])
        elif self.scanner.consume("cons?"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Cons?', [e1])
        elif self.scanner.consume("not"):
            self.scanner.expect("(")
            e1 = self.expr()
            self.scanner.expect(")")
            return AST('Not', [e1])
        elif self.scanner.consume("#"):
            if self.defining is None:
                raise SyntaxError('Use of "#" outside of a function body')
            return AST('ArgRef', value=0)
        elif self.scanner.on_type("atom"):
            atom = self.scanner.token
            self.scanner.scan()
            return AST('Atom', value=atom)
        elif self.scanner.on_type("identifier"):
            ident = self.scanner.token
            self.scanner.scan()
            if self.scanner.on('('):
                self.scanner.expect('(')
                if ident not in self.defined:
                    raise SyntaxError('Undefined function "%s"' % ident)
                args = [self.expr()]
                while self.scanner.consume(','):
                    args.append(self.expr())
                if len(args) != self.defined[ident]:
                    raise SyntaxError('Arity mismatch (expected %d, got %d)' %
                        (self.defined[ident], len(args)))
                self.scanner.expect(')')
                return AST('Call', args, value=ident)
            else:
                if self.defining is None:
                    raise SyntaxError('Reference to argument "%s" '
                                      'outside of a function body' % ident)
                if ident not in self.formals:
                    raise SyntaxError('Undefined argument "%s"' % ident)
                return AST('ArgRef', value=self.formals[ident])
        else:
            return self.smaller()

    def smaller(self):
        if self.scanner.consume("<head"):
            e1 = self.smallerterm()
            return AST('Head', [e1])
        elif self.scanner.consume("<tail"):
            e1 = self.smallerterm()
            return AST('Tail', [e1])
        elif self.scanner.consume("<if"):
            e1 = self.expr()
            self.scanner.expect("then")
            e2 = self.smallerterm()
            self.scanner.expect("else")
            e3 = self.smallerterm()
            return AST('If', [e1, e2, e3])
        else:
            raise SyntaxError('Expected <smaller>, found "%s"' %
                              self.scanner.token)

    def smallerterm(self):
        if self.scanner.consume("#"):
            return AST('ArgRef', value=0)
        else:
            return self.smaller()


### Runtime ###

class Cons(object):
    def __init__(self, head, tail):
        self.head = head
        self.tail = tail

    def __str__(self):
        return "(%s %s)" % (self.head, self.tail)


class Evaluator(object):
    def __init__(self, ast):
        self.fundefs = {}
        for fundef in ast.children[1:]:
            self.fundefs[fundef.value] = {
                'expr': fundef.children[0],
                'args': fundef.children[1:],
            }
        self.bindings = []

    def eval(self, ast):
        if ast.type == 'Atom':
            return ast.value
        elif ast.type == 'Cons':
            v1 = self.eval(ast.children[0])
            v2 = self.eval(ast.children[1])
            return Cons(v1, v2)
        elif ast.type == 'Head':
            v1 = self.eval(ast.children[0])
            try:
                return v1.head
            except AttributeError:
                raise TypeError("head: Not a cons cell")
        elif ast.type == 'Tail':
            v1 = self.eval(ast.children[0])
            try:
                return v1.tail
            except AttributeError:
                raise TypeError("tail: Not a cons cell")
        elif ast.type == 'If':
            v1 = self.eval(ast.children[0])
            if v1 == ':true':
                return self.eval(ast.children[1])
            else:
                return self.eval(ast.children[2])
        elif ast.type == 'Eq?':
            v1 = self.eval(ast.children[0])
            v2 = self.eval(ast.children[1])
            if v1 == v2:
                return ':true'
            else:
                return ':false'
        elif ast.type == 'Cons?':
            v1 = self.eval(ast.children[0])
            if isinstance(v1, Cons):
                return ':true'
            else:
                return ':false'
        elif ast.type == 'Not':
            v1 = self.eval(ast.children[0])
            if v1 == ':true':
                return ':false'
            else:
                return ':true'
        elif ast.type == 'Call':
            fun = self.fundefs[ast.value]
            bindings = self.bindings
            self.bindings = [self.eval(expr) for expr in ast.children]
            result = self.eval(fun['expr'])
            self.bindings = bindings
            return result
        elif ast.type == 'ArgRef':
            return self.bindings[ast.value]
        elif ast.type == 'Program':
            return self.eval(ast.children[0])
        else:
            raise NotImplementedError("%s" % ast)


def main(argv):
    optparser = OptionParser(__doc__)
    optparser.add_option("-a", "--show-ast",
                         action="store_true", dest="show_ast", default=False,
                         help="show parsed AST instead of evaluating")
    optparser.add_option("-t", "--test",
                         action="store_true", dest="test", default=False,
                         help="run test cases and exit")
    (options, args) = optparser.parse_args(argv[1:])
    if options.test:
        import doctest
        (fails, something) = doctest.testmod()
        if fails == 0:
            print "All tests passed."
            sys.exit(0)
        else:
            sys.exit(1)
    file = open(args[0])
    text = file.read()
    file.close()
    p = Parser(text)
    try:
        prog = p.program()
    except SyntaxError as e:
        print >>sys.stderr, str(e)
        sys.exit(1)
    if options.show_ast:
        from pprint import pprint
        pprint(prog)
        sys.exit(0)
    try:
        ev = Evaluator(prog)
        print str(ev.eval(prog))
    except TypeError as e:
        print >>sys.stderr, str(e)
        sys.exit(1)
    sys.exit(0)


if __name__ == "__main__":
    main(sys.argv)
